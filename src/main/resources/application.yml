server:
  port: 8082

spring:
  application:
    name: demo
  rabbitmq:
    host: ${SPRING_RABBITMQ_HOST:localhost}
    port: ${SPRING_RABBITMQ_PORT:5672}
    username: ${SPRING_RABBITMQ_USERNAME:guest}
    password: ${SPRING_RABBITMQ_PASSWORD:guest}
    cache:
      channel:
        size: 50   # increase channel cache for higher throughput

  datasource:
    url: ${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/postgres}
    driver-class-name: org.postgresql.Driver
    username: ${SPRING_DATASOURCE_USERNAME:postgres}
    password: ${SPRING_DATASOURCE_PASSWORD:postgres}

  modulith:
    events:
      externalization:
        enabled: false
      jdbc:
        schema-initialization:
          enabled: true
      # H2 in-memory: disable restart republish (state is ephemeral)
      republish-outstanding-events-on-restart: true
      # Remove completed publications immediately in dev/H2 to avoid growth during long runs
      completion-mode: UPDATE

logging:
  level:
    org.springframework.modulith: INFO
    org.springframework.amqp: INFO

management:
  endpoint:
    health:
      show-details: always
      show-components: always
  endpoints:
    web:
      exposure:
        include: health,info

app:
  amqp:
    new-orders:
      # Control whether to bind queue 'new-orders' to exchange 'BookStoreExchange' with routing key 'orders.new'.
      # Default false to avoid unintended feedback loops with @Externalized(OrderCreatedEvent).
      bind: true
      # Max processing attempts before rejecting to DLQ. Can be overridden via
      # env var SPRING_APPLICATION_JSON or CLI: --app.amqp.new-orders.retry-max-attempts=5
      retry-max-attempts: 3
